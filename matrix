#!/bin/bash
#*********citation some code used/modeled from required reading********

#to do: transpose  matricies before mult ---follow add logic!!!!!!!!!!!!!!!
#! validation files
# and mult AXB to BXC and add same size-- ect, rmv tab at end 
#use remove last char in assignment 

dims () {
    trap "rm -f $inputD; exit" INT  HUP TERM

    if [ "$#" -eq 0 ]
    then
        inputD="inputDims$$"
        touch $inputD
        #echo "cat > input"
        cat > $inputD

    elif [ "$#" -ne 1 ]
    then
        echo "error" 1>&2
        exit 1
    elif [ ! -e $1 ] || [ ! -r $1 ]
    then   
        echo "error" 1>&2
        exit 1
    fi
    lineNum=0
    count=0
    inputD="inputDims$$"
    if [ ! -e $inputD ]  
    then    
        touch $inputD
        cat $1 > $inputD
    fi
    read myline < $inputD #read one line from file and do for loop on nums in line
    for i in $myline    
    do
        count=`expr $count + 1`
    done 

    while read myLine   #read entire doc line by line
    do
        lineNum=`expr $lineNum + 1`
    done < $inputD
    printf "$lineNum "
    printf "$count\n"
    rm -f $inputD
    return 0
}









transpose () {
    if [ "$#" -eq 0 ]
    then
        input=inputFile$$
        touch $input
        #echo "cat > input"
        cat > $input

    elif [ "$#" -ne 1 ]
    then
        echo "error" 1>&2
        exit 1
    elif [ ! -e $1 ] || [ ! -r $1 ]
    then   
        echo "error" 1>&2
        exit 1
    fi
   
    input="inputFile$$"
    if [ ! -e $input ]  
    then    
        #echo " if args"
        input=inputFile$$
        touch $input
        cat $1 > $input
        #cat $input
    fi
    tmpCol="tmpColFile"
    touch $tmpCol$$ #named with PID
    fnlCol="fnlColFile"
    touch $fnlCol$$ #named with PID
    trap "rm -f $tmpCol$$; rm -f $fnlCol$$; rm -f $input; exit;" INT  HUP TERM
    tmp="tmptrp$$"
    touch $tmp
    cat $input > $tmp
    dims $input > /dev/null #get the size with dim --count = rows lineNum = col
    #echo "$lineNum $count"
    cat $tmp > $input
    rm -f $tmp
    #cat $input
    i=1
   # echo "$lineNum $count"
while [ $i -le $count ]
    do
       # printf "%s\t%d\n" "i= " "$i"
        #echo "while"
        #cat $input
        cut -f $i $input > $tmpCol$$ #cut fields of cols one by one put in tmpCol
        #cat $tmpCol$$
        i=`expr $i + 1`
        #truncate -s-1  $fnlCol$$

        cat $tmpCol$$ | tr '\n' '\t' >> "$fnlCol$$" #take tmpCol and append on fnlCol with newlines as tabs
       # cat -A $fnlCol$$  
        truncate -s-1  $fnlCol$$
   
        echo "" >> $fnlCol$$    #add newline at end !!!
        #!might have to change end to pass tests#$%$#$%$#  if =count skip changing to newline and echo skip
         
    done < $input

    cat  $fnlCol$$
    #echo ""
   # cat -A $fnlCol$$
    rm -f $input
    rm -f $fnlCol$$ #get rid of tempfile
    rm -f $tmpCol$$ #get rid of tempfile
    return 0
}








mean () {
    if [ "$#" -eq 0 ]
    then
        input=inputFile$$
        touch $input
        #echo "cat > input"
        cat > $input

    elif [ "$#" -ne 1 ]
    then
        echo "error" 1>&2
        exit 1
    elif [ ! -e $1 ]  || [ ! -r $1 ]
    then   
        echo "error" 1>&2
        exit 1
    fi
   
    input="inputFile$$"
    if [ ! -e $input ]  
    then    
        #echo " if args"
        input=inputFile$$
        touch $input
        cat $1 > $input
        #cat $input
    fi
    tmpCol="tmpColFile"
    touch $tmpCol$$ #named with PID
    fnlCol="fnlColFile"
    touch $fnlCol$$ #named with PID
    trap "rm -f $tmpCol$$; rm -f $fnlCol$$; rm -f $input; exit; " INT  HUP TERM
    tmp="tmpfileM$$"
    touch $tmp
    cat $input > $tmp
    dims $input > /dev/null #get the size with dim --count = rows lineNum = col
    cat $tmp > $input
    rm -f $tmp
i=1
while [ $i -le $count ]
    do
       # printf "%s\t%d\n" "i= " "$i"
        cut -f $i $input > $tmpCol$$ #cut fields of cols one by one put in tmpCol
        #cat $tmpCol$$
        sum=0
        j=0
        while read myfile #read line into loop 
        do
            sum=$(($sum + $myfile)) #sum up line into sum var
        done < $tmpCol$$
        sum=$(( ($sum + ($lineNum/2)*( ($sum>0)*2-1 )) / $lineNum )) #formula for proper rounding in div cited from assignment
       #printf -- "%s" "$sum"
        printf  -- "%s\t" "$sum"  >> "$fnlCol$$"
        i=`expr $i + 1`

    done < $input
    truncate -s-1  $fnlCol$$
    echo "" >> $fnlCol$$
    cat  $fnlCol$$

    #cat -A $fnlCol$$  #test tabs newlines
    rm -f $input
    rm -f $fnlCol$$ #get rid of tempfile
    rm -f $tmpCol$$ #get rid of tempfile
    return 0

}










add () {
    if [ "$#" -ne 2 ]
    then
        echo "error" 1>&2
        exit 1
    elif [ ! -e $1 ] || [ ! -r $1 ]
    then   
        echo "error" 1>&2
        exit 1
    elif [ ! -e $2 ] || [ ! -r $2 ]
    then   
        echo "error" 1>&2
        exit 1
    fi
    
    tmpCol="tmpColFile"
    touch $tmpCol$$ #named with PID
    fnlCol="fnlColFile"
    touch $fnlCol$$ #named with PID
    final="FinalFile"
    touch $final$$ #named with PID
    trap "rm -f $tmpCol$$; rm -f $fnlCol$$; rm -f $final$$; exit;" INT  HUP TERM
    
    dims $1 > $final$$ #get the size with dim --   r1= rows c1  = col of first matrix
    counter=0
    #grab the dimentions of the 2 matricies
    r1=$lineNum
    c1=$count
    dims $2 > $final$$ #get the size with dim --  r2 = rows c2 = col of second matrix input
    r2=$lineNum
    c2=$count
    #echo "$r1 $c1 $r2 $c2"
    printf "" > $final$$
    if [ $r1 -ne $r2 ] || [ $c2 -ne $c1 ]
    then 
        echo   "Matrix sizes not equal for add operation, exiting"  1>&2
        exit 1
    fi
    dims $1 > /dev/null #get the size with dim --count = rows lineNum = col

    i=1

    sum=0

# go back to transpose if wrong shape matrix!!!!!!!!!!!!!!    
    while [ $i -le $lineNum ] #for each line (should be same)
    do
        #echo "i = $i"
        cat $1 | head -n $i | tail -n 1 > $tmpCol$$  #throw specified line in tmpCol file
        cat $2 | head -n $i | tail -n 1 > $fnlCol$$
        read myline1 < $tmpCol$$
        read myline2 < $fnlCol$$
        #echo "$myline1"
        #echo "$myline2"
        counter1=0
        for j in $myline1 #double for loop for adding correct positions in input file to output file 
        do
            ((counter1++))
            #echo "here $j"
            counter2=0 #reset

            for k in $myline2
            do
                ((counter2++))
                #echo "here $j"
                if [ $counter1 -eq $counter2 ]
                then
                    #echo "liip"
                    #echo "$counter1 eq $counter2 "
                    #echo "$j and $k"
                    sum=$(($j + $k)) #sum up line into sum var

                    if [ $counter2 -eq $count ]
                    then
                        printf -- "%s\n" "$sum" >> $final$$ 
                    else 
                        printf -- "%s\t" "$sum" >> $final$$ 
                    fi
                fi
            done
        done
        #echo "" >> $final$$

        i=`expr $i + 1`        #while [ $j -le $count ] #for each number in 1 line (should be same)

    done 

    cat  $final$$  #test tabs newlines
    rm -f $fnlCol$$ #get rid of tempfile
    rm -f $tmpCol$$ #get rid of tempfile
    rm -f $final$$ #get rid of tempfile
    return 0

}












multiply () {
    if [ "$#" -ne 2 ]
    then
        echo "error" 1>&2
        exit 1
    elif [ ! -e $1 ] || [ ! -r $1 ]
    then   
        echo "error" 1>&2
        exit 1
    elif [ ! -e $2 ] || [ ! -r $2 ]
    then   
        echo "error" 1>&2
        exit 1
    fi
    
    tmp="tmpColFile$$"
    touch $tmp #named with PID

    final="FinalFile$$"
    touch $final #named with PID
    trap "rm -f $final; rm -f $tmp; exit; " INT  HUP TERM

    dims $1 > $final #get the size with dim --   r1= rows c1  = col of first matrix
    counter=0
    #grab the dimentions of the 2 matricies
    dims $1 > $final #get the size with dim --   r1= rows c1  = col of first matrix
     #grab the dimentions of the 2 matricies
    r1=$lineNum
    c1=$count
     dims $2 > $final #get the size with dim --  r2 = rows c2 = col of second matrix input
    r2=$lineNum
    c2=$count
    #echo "$r1 $c1 $r2 $c2"
    printf "" > $final
    printf "" > $final
    i=1
    sum=0
    if [ $c1 -ne $r2 ]
    then 
        echo   "Matrix 1 columns not equal to Matrix 2 rows for multiply operation, exiting"  1>&2
        exit 1
    fi
    while [ $i -le $r1 ]
    do
        j=1
        while [ $j -le $c2 ]
        do  
            k=1
            while [ $k -le $c1 ]
            do  
                cat $1 | head -n $i | tail -n 1 | cut -f $k > $tmp  #throw specified line in tmpCol file y
                a=$(<$tmp)
                cat $2 | head -n $k | tail -n 1 | cut -f $j > $tmp  #throw specified line in tmpCol file y
                b=$(<$tmp)
                sum=$(( $sum+($a * $b) ))
                ((k++))
            done

            if [ $j -eq $c2 ]
            then
                printf -- "%s\n" "$sum" >> $final 
            else 
                printf -- "%s\t" "$sum" >> $final 
            fi
            sum=0
            ((j++))
        done
        ((i++))
    done
    
    cat  $final  #test tabs newlines
    rm -f $tmp #get rid of tempfile
    rm -f $final #get rid of tempfile
    return 0

}


$1 "${@:2}"
exit 0